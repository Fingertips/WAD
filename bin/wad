#!/usr/bin/env ruby

# Generated on: 12-09-2013 at 01:24

require 'time'
require 'net/http'
require 'net/https'
require 'digest/md5'
require 'fileutils'
require 'openssl'
require 'base64'

class Presss
  # Computes the Authorization header for a AWS request based on a message,
  # the access key ID and secret access key.
  class Authorization
    attr_accessor :access_key_id, :secret_access_key

    def initialize(access_key_id, secret_access_key)
      @access_key_id, @secret_access_key = access_key_id, secret_access_key
    end

    # Returns the value for the Authorization header for a message contents.
    def header(string)
      'AWS ' + access_key_id + ':' + sign(string)
    end

    # Returns a signature for a AWS request message.
    def sign(string)
      Base64.encode64(hmac_sha1(string)).strip
    end

    def hmac_sha1(string)
      OpenSSL::HMAC.digest('sha1', secret_access_key, string)
    end
  end

  class HTTP
    attr_accessor :config

    def initialize(config)
      @config = config
    end

    # Returns the configured bucket name.
    def bucket_name
      config[:bucket_name]
    end

    def region
      config[:region] || 'us-east-1'
    end

    def domain
      case region
      when 'us-east-1'
        's3.amazonaws.com'
      else
        's3-%s.amazonaws.com' % region
      end
    end

    # Returns the absolute path based on the key for the object.
    def absolute_path(path)
      path.start_with?('/') ? path : '/' + path
    end

    # Returns the canonicalized resource used in the authorization
    # signature for an absolute path to an object.
    def canonicalized_resource(path)
      if bucket_name.nil?
        raise ArgumentError, "Please configure a bucket_name: Presss.config = { bucket_name: 'my-bucket-name }"
      else
        '/' + bucket_name + absolute_path(path)
      end
    end

    # Returns a Presss::Authorization instance for the configured
    # AWS credentials.
    def authorization
      @authorization ||= Presss::Authorization.new(
        config[:access_key_id],
        config[:secret_access_key]
      )
    end

    def signature(verb, expires, path)

    end

    def signed_url(verb, expires, path)
      path = canonicalized_resource(path)
      signature = [ verb.to_s.upcase, nil, nil, expires, path ].join("\n")
      signed = authorization.sign(signature)
      "https://#{domain}#{path}?Signature=#{signed}&Expires=#{expires}&AWSAccessKeyId=#{authorization.access_key_id}"
    end

    def download(path, destination)
      url = signed_url(:get, Time.now.to_i + 600, path)
      Presss.log "path=#{path} signed_url=#{url}"
      system 'curl', '-o', destination, url
      $?.success?
    end

    # Puts an object with a key using a file or string. Optionally pass in
    # the content-type if you want to set a specific one.
    def put(path, file)
      url = signed_url(:put, Time.now.to_i + 600, path)
      system 'curl', '-T', file, url
      $?.success?
    end
  end

  class << self
    attr_accessor :config
    attr_accessor :logger
  end
  self.config = {}

  # Get a object with a certain key.
  def self.download(path, destination)
    t0 = Time.now
    request = Presss::HTTP.new(config)
    log("Trying to GET #{path}")
    if request.download(path, destination)
      log("Downloaded in #{(Time.now - t0).to_i} seconds")
      true
    else
      nil
    end
  end

  # Puts an object with a key using a file or string. Optionally pass in
  # the content-type if you want to set a specific one.
  def self.put(path, filename, content_type='application/x-download')
    request = Presss::HTTP.new(config)
    log("Trying to PUT #{path}")
    request.put(path, filename)
  end

  # Logs to the configured logger if a logger was configured.
  def self.log(message)
    if logger
      logger.info('[Presss] ' + message)
    end
  end
end

# Utility class to push and fetch Bundler directories to speed up
# test runs on Travis-CI
class Wad
  def initialize
    write_cacert
    s3_configure
  end

  def project_root
    Dir.pwd
  end

  def cacert_filename
    File.join(project_root, 'tmp/cacert.pem')
  end

  def write_cacert
    FileUtils.mkdir_p(File.dirname(cacert_filename))
    File.open(cacert_filename, 'wb') do |file|
      file.write(DATA.read)
    end
  end

  def gemfile_lock
    File.join(project_root, 'Gemfile.lock')
  end

  def bundle_name_parts
    [
      File.read(gemfile_lock),
      RUBY_VERSION,
      RUBY_PLATFORM
    ]
  end

  def bundle_name
    Digest::MD5.hexdigest(bundle_name_parts.join)
  end

  def bzip_filename
    File.join(project_root, "tmp/#{bundle_name}.tar.bz2")
  end

  def bundler_path
    '.bundle'
  end

  def s3_bucket_name
    ENV['S3_BUCKET_NAME']
  end

  def s3_credentials
    ENV['S3_CREDENTIALS'].split(':')
  end

  def s3_access_key_id
    s3_credentials[0]
  end

  def s3_secret_access_key
    s3_credentials[1]
  end

  def s3_path
    "#{bundle_name}.tar.bz2"
  end

  def s3_configure
    Presss.config = {
      :bucket_name => s3_bucket_name,
      :access_key_id => s3_access_key_id,
      :secret_access_key => s3_secret_access_key
    }
  end

  def s3_region
    'eu-west-1'
  end

  def s3_write
    log "Trying to write Wad to S3"
    if Presss.put(s3_path, bzip_filename)
      log "Wrote Wad to S3"
    else
      log "Failed to write to S3, debug with `wad -h'"
    end
  end

  def s3_read
    if File.exist?(bzip_filename)
      log "Removing bundle from filesystem"
      FileUtils.rm_f(bzip_filename)
    end

    log "Trying to fetch Wad from S3"
    FileUtils.mkdir_p(File.dirname(bzip_filename))
    Presss.download(s3_path, bzip_filename)
  end

  def zip
    log "Creating Wad with tar (#{bzip_filename})"
    system("cd #{project_root} && tar -cjf #{bzip_filename} #{bundler_path}")
  end


  def unzip
    log "Unpacking Wad with tar (#{bzip_filename})"
    system("cd #{project_root} && tar -xjf #{bzip_filename}")
  end

  def put
    zip
    s3_write
  end

  def get
    if s3_read
      unzip
      true
    else
      false
    end
  end

  def install_bundle
    log "Installing bundle"
    bundle_without = ENV['WAD_BUNDLE_WITHOUT'] || "development production"
    system("bundle install --path .bundle --without='#{bundle_without}'")
  end

  def setup
    if get
      install_bundle
    elsif install_bundle
      put
    else
      raise "Failed properly fetch or install bundle. Please review the logs."
    end
  end

  def log(message)
    puts "[wad] #{message}"
  end

  def self.setup
    new.setup
  end
end

if ARGV.index('-v')
  require 'logger'
  Presss.logger = Logger.new($stdout)
end

Wad.setup
__END__

